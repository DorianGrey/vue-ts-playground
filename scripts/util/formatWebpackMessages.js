/**
 * Note: This utility has originally been established by the create-react-app team,
 * and is used in the corresponding tool. While I appreciate most of the style it applies,
 * I had to adopt the parts that I dislike or consider to be not helpful, and make this more
 * usable for a general purpose, not being tight to `react-dev-utils`.
 * Things got restructured a bit as well to make everything easier to read.
 * Also, since this version is only used in node, there is no need to take care of browser
 * compatibility.
 *
 * @DorianGrey
 */

"use strict";

// Some custom utilities to prettify Webpack output.
// See https://github.com/webpack/webpack/issues/2878 for an issue regarding "structured error reporting".

const formatUtil = require("../../config/formatUtil");

const friendlySyntaxErrorLabel = "Syntax error:";

function isLikelyASyntaxError(message) {
  return message.indexOf(friendlySyntaxErrorLabel) !== -1;
}

function trimExtraNewline(lines) {
  if (lines.length > 2 && lines[1] === "") {
    // Remove extra newline.
    lines.splice(1, 1);
  }
  return lines;
}

function trimLoaderNotation(lines) {
  // Remove webpack-specific loader chain notation from filename.
  // Before:
  // ./~/css-loader!./~/postcss-loader!./src/App.css
  // After:
  // ./src/App.css
  const lastIndexOfBang = lines[0].lastIndexOf("!");
  if (lastIndexOfBang !== -1) {
    lines[0] = lines[0].substr(lastIndexOfBang + 1);
  }
  return lines;
}

function trimEntryPoints(lines) {
  // Webpack adds a list of entry points to warning messages.
  // In most cases, this is misleading resp. unrelated, so it can be removed
  // without losing useful information.
  return lines.filter(line => line.indexOf(" @ ") !== 0);
}

function trimModuleNotFoundMessages(lines) {
  // Cleans up verbose "module not found" messages for files and packages.
  if (lines[1].indexOf("Module not found: ") === 0) {
    lines = [
      lines[0],
      // Clean up message because "Module not found: " is descriptive enough.
      lines[1]
        .replace("Cannot resolve 'file' or 'directory' ", "")
        .replace("Cannot resolve module ", "")
        .replace("Error: ", "")
        .replace("[CaseSensitivePathsPlugin] ", "")
    ];
  }
  return lines;
}

function trimSyntaxErrorMessages(lines) {
  // Cleans up syntax error messages.
  if (lines[1].indexOf("Module build failed: ") === 0) {
    lines[1] = lines[1].replace(
      "Module build failed: SyntaxError:",
      friendlySyntaxErrorLabel
    );
  }
  return lines;
}

function trimExportErrors(lines) {
  // Clean up export errors.
  const exportError = /\s*(.+?)\s*(")?export '(.+?)' was not found in '(.+?)'/;
  if (lines[1].match(exportError)) {
    lines[1] = lines[1].replace(
      exportError,
      "$1 '$4' does not contain an export named '$3'."
    );
  }
  return lines;
}

// Cleans up webpack error messages.
function formatMessage(message, firstLineFormatter) {
  let lines = message.split("\n");

  lines = trimExtraNewline(lines);
  lines = trimLoaderNotation(lines);
  lines = trimEntryPoints(lines);

  // line #0 is filename
  // line #1 is the main error message
  if (!lines[0] || !lines[1]) {
    return lines.join("\n");
  }

  lines = trimModuleNotFoundMessages(lines);
  lines = trimSyntaxErrorMessages(lines);
  lines = trimExportErrors(lines);

  lines[0] = firstLineFormatter(lines[0]);

  // Reassemble the message.
  message = lines.join("\n");
  // Internal stacks are generally useless so we strip them... with the
  // exception of stacks containing `webpack:` because they're normally
  // from user code generated by WebPack.
  message = message.replace(
    /^\s*at\s((?!webpack:).)*:\d+:\d+[\s\)]*(\n|$)/gm,
    ""
  ); // at ... ...:x:y

  return message.trim();
}

function formatWebpackMessages(json) {
  const formattedErrors = json.errors.map(function(message) {
    return formatMessage(message, formatUtil.formatFirstLineMessage);
  });
  const formattedWarnings = json.warnings.map(function(message) {
    return formatMessage(message, formatUtil.formatFirstLineMessage);
  });

  const result = Object.assign({}, json, {
    errors: formattedErrors,
    warnings: formattedWarnings
  });
  if (result.errors.some(isLikelyASyntaxError)) {
    // If there are any syntax errors, show just them.
    // This prevents a confusing linter parsing error
    // preceding a much more useful transpiler syntax error.
    result.errors = result.errors.filter(isLikelyASyntaxError);
  }

  return result;
}

module.exports = formatWebpackMessages;
